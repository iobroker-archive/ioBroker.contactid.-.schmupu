{
  "version": 3,
  "sources": ["../../src/lib/contactid.ts"],
  "sourcesContent": ["import { EventEmitter } from 'events';\nimport * as net from 'net';\nimport * as dp from './datapoints';\nimport * as tools from './tools';\n\n/**\n * Interface subscriber\n */\nexport interface ifsubscriber {\n    subscriber: string;\n    alarmsystem: string;\n}\n\nexport interface ifCID {\n    data: any;\n    subscriber: string;\n    msgtype: string;\n    event: string;\n    eventtext: string;\n    group: string;\n    qualifier: string;\n    sensor: string;\n    checksum: string;\n}\n\n/**\n * Contact ID Klasse\n */\nexport class ContactID extends EventEmitter {\n    private subscribers: ifsubscriber[];\n    private port: number;\n    private host: string;\n    private logger: any;\n    private servertcp: net.Server;\n\n    /**\n     * Contructor\n     *\n     * @param parameter parameter\n     * @param parameter.host bind host\n     * @param parameter.port bind port\n     * @param parameter.logger logger\n     */\n    public constructor(parameter: { host: string; port: number; logger?: any }) {\n        super();\n        this.host = parameter.host;\n        this.port = parameter.port;\n        this.subscribers = [];\n        if (parameter.logger) {\n            this.logger = {\n                info: parameter.logger.info ? parameter.logger.info : parameter.logger,\n                debug: parameter.logger.debug ? parameter.logger.debug : parameter.logger,\n                error: parameter.logger.error ? parameter.logger.error : parameter.logger,\n            };\n        }\n        this.servertcp = net.createServer();\n    }\n\n    /**\n     * Set Subscribers\n     *\n     * @param subcribers subscriber\n     */\n    public setSubscribers(subcribers: ifsubscriber[]): void {\n        this.subscribers = subcribers;\n        if (this.subscribers.length === 0) {\n            throw new Error(`Subscribers are missing!`);\n        }\n    }\n\n    /**\n     * read configuration by subscriber and return the alarmsytem\n     *\n     * @param subscriber subscriber\n     * @returns alarmsystem\n     */\n    private getAlarmSystem(subscriber: string): string {\n        return this.getSubscriberInfo(subscriber).alarmsystem;\n    }\n\n    /**\n     * Get configuratoin for subscriber\n     *\n     * @param subscriber subscriber\n     * @returns configuration\n     */\n    private getSubscriberInfo(subscriber: string): ifsubscriber {\n        for (const key of this.subscribers) {\n            if (key.subscriber === subscriber) {\n                return key;\n            }\n        }\n        throw new Error(`Subscriber ${subscriber} unknown. Not found in configuratin!`);\n    }\n\n    /**\n     * Acknowledge for CID\n     *\n     * @param cid cid\n     */\n    public ackCID(cid: ifCID): any {\n        let ack = undefined;\n        switch (this.getAlarmSystem(cid.subscriber)) {\n            case 'lupusec_xt1':\n                ack = Buffer.alloc(1);\n                ack[0] = 6; //Acknowledge Lupusex 0x6\n                break;\n            case 'lupusec_xt1p':\n            case 'lupusec_xt2':\n            case 'lupusec_xt2p':\n            case 'lupusec_xt3':\n            case 'lupusec_xt4':\n                // ack = cid.data; // komplette Nachricht wieder zur\u00FCckegeben\n                ack = Buffer.alloc(1);\n                ack[0] = 6; //Acknowledge Lupusex 0x6\n                break;\n            default:\n                ack = cid.data;\n        }\n        return ack;\n    }\n\n    /**\n     * Text for Events\n     *\n     * @param event Eventnummber\n     */\n    private getEventText(event: string): string {\n        const events: dp.defEvents = dp.events;\n        return events[event] || '';\n    }\n\n    /**\n     * parse contactid and put into object\n     *\n     * @param data contactid message from alarm system\n     */\n    public parseCID(data: any): ifCID {\n        if (!data) {\n            throw new Error(`Could not parse ContactID message, because it is empty`);\n        }\n        const strdata = data.toString().trim();\n        const reg = /^\\[(.+) (.{2})(.)(.{3})(.{2})(.{3})(.)(.*)\\]/gm;\n        const match = reg.exec(strdata);\n        if (match) {\n            // <ACCT><MT><QXYZ><GG><CCC><S>\n            const cid = {\n                data: strdata,\n                subscriber: match[1].trim(),\n                msgtype: match[2],\n                qualifier: match[3],\n                event: match[4],\n                eventtext: this.getEventText(match[4]),\n                group: match[5],\n                sensor: match[6],\n                checksum: match[7],\n            };\n            return cid;\n        }\n        throw new Error(`Could not parse ContactID message ${strdata}.`);\n    }\n\n    /**\n     * start socket server for listining for contact IDs\n     */\n    public serverStartTCP(): void {\n        // this.servertcp = net.createServer();\n        this.servertcp.on('connection', sock => {\n            const remoteAddress = `${sock.remoteAddress}:${sock.remotePort}`;\n            this.logger && this.logger.debug(`New client connected: ${remoteAddress}`);\n            sock.on('data', data => {\n                try {\n                    this.emit('data', data);\n                    this.logger &&\n                        this.logger.info(`received from ${remoteAddress} following data: ${JSON.stringify(data)}`);\n                    this.logger &&\n                        this.logger.info(`received from ${remoteAddress} following message: ${data.toString().trim()}`);\n                    const cid = this.parseCID(data);\n                    this.logger && this.logger.debug(`Paresed message: ${JSON.stringify(cid)}`);\n                    this.logger && this.logger.debug(`Paresed message: ${JSON.stringify(cid)}`);\n                    const ack = this.ackCID(cid);\n                    this.emit('cid', cid, undefined);\n                    this.logger &&\n                        this.logger.info(`sending to ${remoteAddress} following ACK message: ${ack.toString().trim()}`);\n                    sock.end(ack);\n                } catch (err) {\n                    this.logger && this.logger.info('Received message could not be parsed!');\n                    this.emit('sia', undefined, tools.getErrorMessage(err));\n                    sock.end();\n                }\n            });\n            sock.on('close', () => {\n                this.logger && this.logger.info(`connection from ${remoteAddress} closed`);\n            });\n            sock.on('error', err => {\n                this.logger && this.logger.error(`Connection ${remoteAddress} error:  ${tools.getErrorMessage(err)}`);\n                this.emit('error', tools.getErrorMessage(err));\n            });\n        });\n        this.servertcp.on('close', () => {\n            this.logger && this.logger.info(`TCP Listen server on ${this.host}:${this.port} closed`);\n            this.emit('close');\n        });\n        this.servertcp.listen(this.port, this.host, () => {\n            this.logger &&\n                this.logger.info(`ContactID Server listening on IP-Address (TCP): ${this.host}:${this.port}`);\n        });\n    }\n\n    /**\n     * Stop TCP Server\n     */\n    public serverStopTCP(): void {\n        if (this.servertcp) {\n            this.servertcp.close(err => {\n                if (err) {\n                    throw new Error(`Could not close TCP Listen server on : ${this.host}:${this.port}`);\n                } else {\n                    this.logger.info(`Close TCP Listen server on: ${this.host}:${this.port}`);\n                }\n            });\n        }\n    }\n\n    /**\n     * Wait (sleep) x seconds\n     *\n     * @param seconds time in seconds\n     * @returns void\n     */\n    public static wait(seconds: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
